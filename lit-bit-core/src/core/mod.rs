// src/core/mod.rs
// This module will house core state machine logic and types.
// For now, it's a placeholder.

use heapless::Vec; // Added for hierarchical path tracking

// Re-export the StateMachine trait for easier use if core types implement it.
// Potentially, the macro-generated machine would be in a submodule of `core` or a user module.
pub use crate::StateMachine;

// --- Basic Type Placeholders (will be generic/generated by macro later) ---

// Using simple u8 for IDs as placeholders. Macro would generate enums.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct StateId(pub u8);

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct EventId(pub u8);

// Placeholder for context data. Macro would use the user-defined struct.
#[derive(Debug, Clone, Default)]
pub struct DefaultContext {/* ... fields ... */}

// Define function pointer types for actions and guards
pub type ActionFn<ContextType> = fn(&mut ContextType);
pub type GuardFn<ContextType, EventType> = fn(context: &ContextType, event: EventType) -> bool;

// --- Flat State Machine Definition ---

/// Represents a simple transition for a flat state machine.
#[derive(Debug, Copy, Clone)]
pub struct Transition<StateType, EventType, ContextType> {
    pub from_state: StateType,
    pub event: EventType,
    pub to_state: StateType,
    pub action: Option<ActionFn<ContextType>>,
    pub guard: Option<GuardFn<ContextType, EventType>>,
}

/// Defines the structure of a simple, flat state machine.
/// This would be largely generated by the `statechart!` macro.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct StateNode<StateType, ContextType>
where
    StateType: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    ContextType: Clone + 'static,
{
    pub id: StateType, // The unique ID of this state (a variant of the generated StateId enum)
    pub parent: Option<StateType>, // ID of the parent state, if any
    pub initial_child: Option<StateType>, // ID of the initial child state, if this is a composite state
    pub entry_action: Option<ActionFn<ContextType>>,
    pub exit_action: Option<ActionFn<ContextType>>,
    pub is_parallel: bool, // New field
}

#[derive(Clone)]
pub struct MachineDefinition<StateType, EventType, ContextType>
where
    StateType: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static, // This will be the generated StateId enum
    EventType: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    ContextType: Clone + 'static,
{
    pub states: &'static [StateNode<StateType, ContextType>],
    pub transitions: &'static [Transition<StateType, EventType, ContextType>],
    pub initial_leaf_state: StateType,
}

// Manual Debug impl to avoid requiring StateType, EventType, ContextType to be Debug for MachineDefinition itself to be Debug
impl<StateType, EventType, ContextType> core::fmt::Debug
    for MachineDefinition<StateType, EventType, ContextType>
where
    StateType: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    EventType: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    ContextType: Clone + core::fmt::Debug + 'static,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("MachineDefinition")
            .field("states", &self.states) // StateNode needs Debug for this to be useful
            .field("transitions", &self.transitions)
            .field("initial_leaf_state", &self.initial_leaf_state)
            .finish()
    }
}

impl<StateType, EventType, ContextType> MachineDefinition<StateType, EventType, ContextType>
where
    StateType: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    EventType: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    ContextType: Clone + 'static,
{
    pub const fn new(
        states: &'static [StateNode<StateType, ContextType>],
        transitions: &'static [Transition<StateType, EventType, ContextType>],
        initial_leaf_state: StateType,
    ) -> Self {
        MachineDefinition {
            states,
            transitions,
            initial_leaf_state,
        }
    }

    // Helper to find a state node by its ID
    pub fn get_state_node(
        &self,
        state_id: StateType,
    ) -> Option<&'static StateNode<StateType, ContextType>> {
        self.states.iter().find(|s_node| s_node.id == state_id)
    }

    // Helper to get the parent of a state, if it exists
    pub fn get_parent_of(&self, state_id: StateType) -> Option<StateType> {
        self.get_state_node(state_id)
            .and_then(|s_node| s_node.parent)
    }
}

// --- Runtime Instance ---

// Placeholder for hierarchy depth, make configurable or detect via macro later.
const MAX_HIERARCHY_DEPTH: usize = 8;
// Make MAX_ACTIVE_REGIONS public so it can be accessed by lib.rs
pub const MAX_ACTIVE_REGIONS: usize = 4; // Max parallel regions/active states we can track

/// Runtime instance of a state machine.
#[derive(Debug)]
pub struct Runtime<StateType, EventType, ContextType>
where
    StateType: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    EventType: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    ContextType: Clone + 'static,
{
    machine_def: MachineDefinition<StateType, EventType, ContextType>,
    active_leaf_states: heapless::Vec<StateType, MAX_ACTIVE_REGIONS>,
    context: ContextType,
}

impl<StateType, EventType, ContextType> Runtime<StateType, EventType, ContextType>
where
    StateType: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    EventType: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    ContextType: Clone + 'static,
{
    /// Creates a new runtime instance for the given machine definition and initial context.
    ///
    /// # Panics
    ///
    /// Panics if the determined state hierarchy depth for the initial state exceeds `MAX_HIERARCHY_DEPTH`.
    /// This indicates that the state machine has a deeper nesting than currently supported by the fixed-size
    /// internal path tracking vector.
    pub fn new(
        machine_def: MachineDefinition<StateType, EventType, ContextType>,
        mut initial_context: ContextType,
    ) -> Self {
        let top_level_initial_state_id = machine_def.initial_leaf_state;
        let mut active_states_vec = heapless::Vec::<StateType, MAX_ACTIVE_REGIONS>::new();

        // For now, assume initial_leaf_state is a single state.
        // If it were parallel, this logic would need to find all initial leaves of its regions.
        // The existing logic in `new` already finds the *deepest* initial leaf and executes entry actions.
        // We'll use that deepest leaf as the single active state for non-parallel initial setup.

        let mut path_to_deepest_initial: heapless::Vec<StateType, MAX_HIERARCHY_DEPTH> =
            heapless::Vec::new();
        let mut current_id_for_path = Some(top_level_initial_state_id);
        while let Some(id) = current_id_for_path {
            path_to_deepest_initial
                .push(id)
                .expect("Path too long for initial state hierarchy");
            if let Some(node) = machine_def.get_state_node(id) {
                current_id_for_path = node.initial_child;
            } else {
                current_id_for_path = None;
            }
        }

        for &state_to_enter in &path_to_deepest_initial {
            if let Some(state_node) = machine_def.get_state_node(state_to_enter) {
                if let Some(entry_fn) = state_node.entry_action {
                    entry_fn(&mut initial_context);
                }
            }
        }

        let actual_initial_leaf_id = path_to_deepest_initial
            .last()
            .copied()
            .unwrap_or(top_level_initial_state_id);

        active_states_vec
            .push(actual_initial_leaf_id)
            .expect("Failed to push initial state");

        Runtime {
            machine_def,
            active_leaf_states: active_states_vec,
            context: initial_context,
        }
    }

    pub fn state(&self) -> heapless::Vec<StateType, MAX_ACTIVE_REGIONS> {
        self.active_leaf_states.clone()
    }

    pub fn context(&self) -> &ContextType {
        &self.context
    }

    pub fn context_mut(&mut self) -> &mut ContextType {
        &mut self.context
    }

    // --- Helper methods for hierarchical transitions ---

    /// Collects the path from a leaf state up to the root, including the leaf itself.
    /// The path is returned with the leaf state at index 0 and ancestors following.
    fn get_path_to_root(&self, leaf_state_id: StateType) -> Vec<StateType, MAX_HIERARCHY_DEPTH> {
        let mut path: Vec<StateType, MAX_HIERARCHY_DEPTH> = Vec::new();
        let mut current_id = Some(leaf_state_id);
        while let Some(id) = current_id {
            // Should not fail if MAX_HIERARCHY_DEPTH is reasonable and machine is validated
            path.push(id)
                .expect("Path too long when getting path to root");
            current_id = self.machine_def.get_parent_of(id);
        }
        path // Path is [leaf, parent, grandparent, ..., root]
    }

    /// Finds the Least Common Ancestor (LCA) of two states.
    fn find_lca(&self, state1_id: StateType, state2_id: StateType) -> Option<StateType> {
        if state1_id == state2_id {
            return Some(state1_id);
        }

        let path1 = self.get_path_to_root(state1_id); // [leaf1, p1, ..., root]
        let path2 = self.get_path_to_root(state2_id); // [leaf2, p2, ..., root]

        // Check if one is an ancestor of the other
        // .contains() checks if an element is in the Vec
        if path1.contains(&state2_id) {
            // If state2_id is in the path from state1_id to root, state2_id is an ancestor or state1_id itself
            return Some(state2_id);
        }
        if path2.contains(&state1_id) {
            // If state1_id is in the path from state2_id to root, state1_id is an ancestor or state2_id itself
            return Some(state1_id);
        }

        // General case: find the first common ancestor by checking path1's ancestors (root down) against path2
        // path1.iter().rev() iterates from root towards leaf1
        path1
            .iter()
            .rev()
            .find(|&&ancestor1_from_path1| path2.contains(&ancestor1_from_path1))
            .copied()
    }

    /// Executes exit actions from a leaf state up to (but not including) a common ancestor (LCA).
    fn execute_exit_actions_up_to_lca(
        &mut self,
        leaf_state_id: StateType,
        lca_id: Option<StateType>,
    ) {
        let mut current_id_opt = Some(leaf_state_id);
        while let Some(current_id) = current_id_opt {
            if lca_id == Some(current_id) {
                // Stop if we reached the LCA
                break;
            }
            if let Some(state_node) = self.machine_def.get_state_node(current_id) {
                if let Some(exit_fn) = state_node.exit_action {
                    exit_fn(&mut self.context);
                }
            }
            current_id_opt = self.machine_def.get_parent_of(current_id);
        }
    }

    /// Helper to recursively enter a state and then its initial children until a leaf is reached.
    /// Executes entry actions for all states entered along this path.
    fn enter_submachine_to_initial_leaf(&mut self, state_to_enter: StateType) -> StateType {
        if let Some(state_node) = self.machine_def.get_state_node(state_to_enter) {
            if let Some(entry_fn) = state_node.entry_action {
                entry_fn(&mut self.context);
            }
        }

        let mut current_leaf = state_to_enter;
        let mut current_composite_opt = Some(state_to_enter);

        while let Some(composite_id) = current_composite_opt {
            if let Some(composite_node) = self.machine_def.get_state_node(composite_id) {
                if let Some(initial_child_id) = composite_node.initial_child {
                    if let Some(child_node) = self.machine_def.get_state_node(initial_child_id) {
                        if let Some(entry_fn) = child_node.entry_action {
                            entry_fn(&mut self.context);
                        }
                    }
                    current_leaf = initial_child_id;
                    current_composite_opt = Some(initial_child_id); // Continue drilling if this child is also composite
                } else {
                    current_composite_opt = None; // Reached a leaf or a non-composite state with no initial child
                }
            } else {
                current_composite_opt = None; // Should not happen if ID is valid
            }
        }
        current_leaf // Return the actual leaf state reached
    }

    /// Executes entry actions from a state (typically child of LCA) down to a target leaf state.
    /// This involves entering the `target_state_id` and then drilling down to its own initial leaf if it's composite.
    fn execute_entry_actions_from_lca(
        &mut self,
        target_state_id: StateType,
        lca_id: Option<StateType>,
    ) -> StateType {
        let mut path_from_target_to_root = self.get_path_to_root(target_state_id); // [target, p, ..., root]
        path_from_target_to_root.reverse(); // Now [root, ..., p, target]

        let lca_pos_in_reversed_path =
            lca_id.and_then(|lca| path_from_target_to_root.iter().position(|&s| s == lca));

        let start_index_for_entry = match lca_pos_in_reversed_path {
            Some(pos) => pos + 1, // Start entering from the child of LCA
            None => 0, // No LCA (or different trees), enter full path from root's first child on path
        };

        let mut final_entered_leaf = target_state_id; // Default if no entry path found or target is simple leaf at LCA

        if start_index_for_entry < path_from_target_to_root.len() {
            for i in start_index_for_entry..path_from_target_to_root.len() {
                let state_to_enter_explicitly = path_from_target_to_root[i];
                if state_to_enter_explicitly == target_state_id {
                    final_entered_leaf =
                        self.enter_submachine_to_initial_leaf(state_to_enter_explicitly);
                    // Once the designated target of the transition is entered (and its submachine),
                    // we don't need to process further states from path_from_target_to_root,
                    // as enter_submachine_to_initial_leaf handles the rest of the descent.
                    break;
                }
                // This is an intermediate composite state on the path from LCA's child to target_state_id.
                if let Some(state_node) = self.machine_def.get_state_node(state_to_enter_explicitly)
                {
                    if let Some(entry_fn) = state_node.entry_action {
                        entry_fn(&mut self.context);
                    }
                }
            }
        } else if lca_id.is_some() && lca_id == Some(target_state_id) {
            // This case handles when the target_state_id is the LCA itself.
            // No states between LCA and target to enter; just enter the target and its submachine.
            final_entered_leaf = self.enter_submachine_to_initial_leaf(target_state_id);
        }
        // If start_index_for_entry >= path_from_target_to_root.len() AND it's not the (LCA == target) case:
        // This implies the target was an ancestor of or same as LCA's child used for start_index.
        // Or, target_state_id was the LCA, and was handled by the else-if.
        // If path was empty (e.g. target is root and no lca or lca is root), loop isn't entered.
        // In such cases, if not handled by (LCA == target), `final_entered_leaf` remains `target_state_id`,
        // which might need a final call to `enter_submachine_to_initial_leaf` if no loop ran.
        // However, the above logic with `break` and the `else if` should cover most direct scenarios.
        // A scenario: target_state_id is P1, lca_id is None. start_index=0. path=[P1]. Loop for P1, calls enter_submachine(P1).

        final_entered_leaf
    }

    /// Sends an event to the state machine for processing.
    ///
    /// This is a **TEMPORARY IMPLEMENTATION** and will be significantly refactored
    /// to support parallel states. Currently, it only considers the first active state.
    ///
    /// # Panics
    ///
    /// Panics if `active_leaf_states.push()` fails after a transition, which might occur
    /// if `MAX_ACTIVE_REGIONS` is too small (e.g., 0, though current code sets to 1 state).
    /// This specific panic condition will change as parallel state logic is implemented.
    pub fn send(&mut self, event: EventType) -> bool {
        if self.active_leaf_states.is_empty() {
            return false; // No active state to handle event
        }
        let primary_active_state_id = self.active_leaf_states[0]; // TEMPORARY

        let mut current_check_state_id = Some(primary_active_state_id);

        while let Some(check_state_id) = current_check_state_id {
            for transition in self.machine_def.transitions {
                if transition.from_state == check_state_id && transition.event == event {
                    if let Some(guard_fn) = transition.guard {
                        if !guard_fn(&self.context, event) {
                            continue;
                        }
                    }

                    let old_leaf_state_id = primary_active_state_id; // Was self.current_state_id
                    let target_state_id_from_transition = transition.to_state;

                    // Self-transition logic might need care with multiple active states
                    if old_leaf_state_id == target_state_id_from_transition
                        && transition.from_state == old_leaf_state_id
                    {
                        if let Some(action_fn) = transition.action {
                            action_fn(&mut self.context);
                        }
                        return true;
                    }

                    let lca_id = self.find_lca(old_leaf_state_id, target_state_id_from_transition);
                    self.execute_exit_actions_up_to_lca(old_leaf_state_id, lca_id);

                    if let Some(action_fn) = transition.action {
                        action_fn(&mut self.context);
                    }

                    // Entry actions and updating active_leaf_states will be complex.
                    // For now, just assume it transitions to a single state.
                    let new_current_leaf_id = self
                        .execute_entry_actions_from_lca(target_state_id_from_transition, lca_id);

                    self.active_leaf_states.clear();
                    self.active_leaf_states
                        .push(new_current_leaf_id)
                        .expect("Failed to set new active state");

                    return true;
                }
            }
            current_check_state_id = self.machine_def.get_parent_of(check_state_id);
        }
        false
    }
}

impl<StateType, EventType, ContextType> StateMachine for Runtime<StateType, EventType, ContextType>
where
    StateType: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    EventType: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    ContextType: Clone + 'static,
{
    type State = StateType;
    type Event = EventType;
    type Context = ContextType;

    fn send(&mut self, event: Self::Event) -> bool {
        Runtime::send(self, event)
    }

    fn state(&self) -> heapless::Vec<Self::State, MAX_ACTIVE_REGIONS> {
        self.active_leaf_states.clone()
    }

    fn context(&self) -> &Self::Context {
        &self.context
    }

    fn context_mut(&mut self) -> &mut Self::Context {
        &mut self.context
    }
}

#[cfg(test)]
mod tests {
    use super::*; //Imports S, E, C types from parent
    use crate::core::DefaultContext; // Ensure DefaultContext is in scope

    #[allow(dead_code)] // Allow dead code for S2 variant and potentially others during dev
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestState {
        S0,
        S1,
        S2,
    }

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestEvent {
        E0,
        E1,
    }

    // Using the DefaultContext from the parent module for this alias
    type TestContextForEmpty = DefaultContext;

    // Define CounterContext at the module scope for tests
    #[derive(Clone, Debug, Default, PartialEq, Eq)]
    struct CounterContext {
        count: i32,
    }

    fn increment_action(context: &mut CounterContext) {
        context.count += 1;
    }
    fn count_is_zero_guard(context: &CounterContext, _event: TestEvent) -> bool {
        context.count == 0
    }

    // Placeholder for states, to be generated by macro later
    const TEST_STATENODES_EMPTY_CTX: &[StateNode<TestState, TestContextForEmpty>] = &[];
    const TEST_STATENODES_COUNTER_CTX: &[StateNode<TestState, CounterContext>] = &[];

    // --- New Test Setup for Hierarchical Transitions ---

    const MAX_LOG_ENTRIES: usize = 32;
    const MAX_LOG_STRING_LEN: usize = 64; // Max length for a logged action string

    #[derive(Clone, Debug, Default, PartialEq, Eq)]
    struct HierarchicalActionLogContext {
        log: Vec<heapless::String<MAX_LOG_STRING_LEN>, MAX_LOG_ENTRIES>,
    }

    impl HierarchicalActionLogContext {
        fn log_action(&mut self, action_description: &str) {
            let mut s = heapless::String::<MAX_LOG_STRING_LEN>::new();
            s.push_str(action_description).expect("Log string too long");
            self.log.push(s).expect("Log full");
        }
        fn get_log(&self) -> &Vec<heapless::String<MAX_LOG_STRING_LEN>, MAX_LOG_ENTRIES> {
            &self.log
        }
    }

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestHierarchyState {
        ParentOne,
        ChildOneAlpha,            // Child of ParentOne
        GrandchildOneAlphaXray,   // Child of ChildOneAlpha
        GrandchildOneAlphaYankee, // Child of ChildOneAlpha
        ChildOneBravo,            // Child of ParentOne
        ParentTwo,
        ChildTwoAlpha, // Child of ParentTwo
    }

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestHierarchyEvent {
        EventTriggerP1ToP2,        // ParentOne to ParentTwo
        EventTriggerToSibling,     // ChildOneAlpha to ChildOneBravo
        EventTriggerToParent,      // GrandchildOneAlphaXray to ChildOneAlpha
        EventTriggerToGrandparent, // GrandchildOneAlphaYankee to ParentOne
        EventTriggerToCousinChild, // ChildOneBravo to GrandchildOneAlphaYankee
        EventTriggerParentReentry, // ChildOneBravo to ParentOne (expect re-entry to P1 initial)
        EventTriggerP2ToP1,        // ParentTwo to ParentOne
        EventTriggerP1ToC1B,       // ParentOne to ChildOneBravo (new)
    }

    // Helper action functions for logging
    fn log_enter_parent_one(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("EnterParentOne");
    }
    fn log_exit_parent_one(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("ExitParentOne");
    }
    fn log_enter_child_one_alpha(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("EnterChildOneAlpha");
    }
    fn log_exit_child_one_alpha(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("ExitChildOneAlpha");
    }
    fn log_enter_grandchild_one_alpha_xray(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("EnterGrandchildOneAlphaXray");
    }
    fn log_exit_grandchild_one_alpha_xray(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("ExitGrandchildOneAlphaXray");
    }
    fn log_enter_grandchild_one_alpha_yankee(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("EnterGrandchildOneAlphaYankee");
    }
    fn log_exit_grandchild_one_alpha_yankee(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("ExitGrandchildOneAlphaYankee");
    }
    fn log_enter_child_one_bravo(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("EnterChildOneBravo");
    }
    fn log_exit_child_one_bravo(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("ExitChildOneBravo");
    }
    fn log_enter_parent_two(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("EnterParentTwo");
    }
    fn log_exit_parent_two(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("ExitParentTwo");
    }
    fn log_enter_child_two_alpha(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("EnterChildTwoAlpha");
    }
    fn log_exit_child_two_alpha(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("ExitChildTwoAlpha");
    }
    fn log_transition_action(ctx: &mut HierarchicalActionLogContext) {
        ctx.log_action("TransitionAction");
    }

    const TEST_HIERARCHY_STATENODES: &[StateNode<
        TestHierarchyState,
        HierarchicalActionLogContext,
    >] = &[
        // ParentOne level
        StateNode {
            id: TestHierarchyState::ParentOne,
            parent: None,
            initial_child: Some(TestHierarchyState::ChildOneAlpha),
            entry_action: Some(log_enter_parent_one),
            exit_action: Some(log_exit_parent_one),
            is_parallel: false,
        },
        // Children of ParentOne
        StateNode {
            id: TestHierarchyState::ChildOneAlpha,
            parent: Some(TestHierarchyState::ParentOne),
            initial_child: Some(TestHierarchyState::GrandchildOneAlphaXray),
            entry_action: Some(log_enter_child_one_alpha),
            exit_action: Some(log_exit_child_one_alpha),
            is_parallel: false,
        },
        StateNode {
            id: TestHierarchyState::ChildOneBravo,
            parent: Some(TestHierarchyState::ParentOne),
            initial_child: None, // Leaf state
            entry_action: Some(log_enter_child_one_bravo),
            exit_action: Some(log_exit_child_one_bravo),
            is_parallel: false,
        },
        // Grandchildren of ParentOne (children of ChildOneAlpha)
        StateNode {
            id: TestHierarchyState::GrandchildOneAlphaXray,
            parent: Some(TestHierarchyState::ChildOneAlpha),
            initial_child: None, // Leaf state
            entry_action: Some(log_enter_grandchild_one_alpha_xray),
            exit_action: Some(log_exit_grandchild_one_alpha_xray),
            is_parallel: false,
        },
        StateNode {
            id: TestHierarchyState::GrandchildOneAlphaYankee,
            parent: Some(TestHierarchyState::ChildOneAlpha),
            initial_child: None, // Leaf state
            entry_action: Some(log_enter_grandchild_one_alpha_yankee),
            exit_action: Some(log_exit_grandchild_one_alpha_yankee),
            is_parallel: false,
        },
        // ParentTwo level
        StateNode {
            id: TestHierarchyState::ParentTwo,
            parent: None,
            initial_child: Some(TestHierarchyState::ChildTwoAlpha),
            entry_action: Some(log_enter_parent_two),
            exit_action: Some(log_exit_parent_two),
            is_parallel: false,
        },
        // Children of ParentTwo
        StateNode {
            id: TestHierarchyState::ChildTwoAlpha,
            parent: Some(TestHierarchyState::ParentTwo),
            initial_child: None, // Leaf state
            entry_action: Some(log_enter_child_two_alpha),
            exit_action: Some(log_exit_child_two_alpha),
            is_parallel: false,
        },
    ];

    const TEST_HIERARCHY_TRANSITIONS: &[Transition<
        TestHierarchyState,
        TestHierarchyEvent,
        HierarchicalActionLogContext,
    >] = &[
        // EventTriggerP1ToP2: ParentOne to ParentTwo
        Transition {
            from_state: TestHierarchyState::ParentOne,
            event: TestHierarchyEvent::EventTriggerP1ToP2,
            to_state: TestHierarchyState::ParentTwo,
            action: Some(log_transition_action),
            guard: None,
        },
        // New transition for ParentOne to ChildOneBravo
        Transition {
            from_state: TestHierarchyState::ParentOne,
            event: TestHierarchyEvent::EventTriggerP1ToC1B,
            to_state: TestHierarchyState::ChildOneBravo,
            action: Some(log_transition_action), // Add a transition action
            guard: None,
        },
        // EventTriggerToSibling: ChildOneAlpha to ChildOneBravo
        Transition {
            from_state: TestHierarchyState::ChildOneAlpha,
            event: TestHierarchyEvent::EventTriggerToSibling,
            to_state: TestHierarchyState::ChildOneBravo,
            action: Some(log_transition_action),
            guard: None,
        },
        // EventTriggerToParent: GrandchildOneAlphaXray to ChildOneAlpha
        Transition {
            from_state: TestHierarchyState::GrandchildOneAlphaXray,
            event: TestHierarchyEvent::EventTriggerToParent,
            to_state: TestHierarchyState::ChildOneAlpha,
            action: Some(log_transition_action),
            guard: None,
        },
        // EventTriggerToGrandparent: GrandchildOneAlphaYankee to ParentOne
        Transition {
            from_state: TestHierarchyState::GrandchildOneAlphaYankee,
            event: TestHierarchyEvent::EventTriggerToGrandparent,
            to_state: TestHierarchyState::ParentOne,
            action: Some(log_transition_action),
            guard: None,
        },
        // EventTriggerToCousinChild: ChildOneBravo to GrandchildOneAlphaYankee
        Transition {
            from_state: TestHierarchyState::ChildOneBravo,
            event: TestHierarchyEvent::EventTriggerToCousinChild,
            to_state: TestHierarchyState::GrandchildOneAlphaYankee,
            action: Some(log_transition_action),
            guard: None,
        },
        // EventTriggerParentReentry: ChildOneBravo to ParentOne (target is composite ParentOne)
        Transition {
            from_state: TestHierarchyState::ChildOneBravo,
            event: TestHierarchyEvent::EventTriggerParentReentry,
            to_state: TestHierarchyState::ParentOne, // Target ParentOne, should re-enter its initial path
            action: Some(log_transition_action),
            guard: None,
        },
        // EventTriggerP2ToP1: ParentTwo to ParentOne
        Transition {
            from_state: TestHierarchyState::ParentTwo,
            event: TestHierarchyEvent::EventTriggerP2ToP1,
            to_state: TestHierarchyState::ParentOne,
            action: Some(log_transition_action),
            guard: None,
        },
    ];

    #[test]
    fn hierarchical_machine_starts_in_correct_initial_leaf_with_entry_actions() {
        let machine_def = MachineDefinition::new(
            TEST_HIERARCHY_STATENODES,
            TEST_HIERARCHY_TRANSITIONS,
            TestHierarchyState::ParentOne, // Top-level initial state for the machine definition
        );

        let initial_context = HierarchicalActionLogContext::default();
        let runtime = Runtime::new(machine_def, initial_context);

        // Check final leaf state
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaXray]
        );

        // Check entry action log
        let mut expected_log_vec: Vec<heapless::String<MAX_LOG_STRING_LEN>, MAX_LOG_ENTRIES> =
            Vec::new();

        let mut s1 = heapless::String::<MAX_LOG_STRING_LEN>::new();
        s1.push_str("EnterParentOne").unwrap();
        expected_log_vec.push(s1).unwrap();

        let mut s2 = heapless::String::<MAX_LOG_STRING_LEN>::new();
        s2.push_str("EnterChildOneAlpha").unwrap();
        expected_log_vec.push(s2).unwrap();

        let mut s3 = heapless::String::<MAX_LOG_STRING_LEN>::new();
        s3.push_str("EnterGrandchildOneAlphaXray").unwrap();
        expected_log_vec.push(s3).unwrap();

        assert_eq!(runtime.context().get_log(), &expected_log_vec);
    }

    #[test]
    fn test_sibling_transition_with_lca() {
        let machine_def = MachineDefinition::new(
            TEST_HIERARCHY_STATENODES,
            TEST_HIERARCHY_TRANSITIONS,
            TestHierarchyState::ParentOne, // Initial state path will lead to GrandchildOneAlphaXray
        );

        let mut runtime = Runtime::new(machine_def, HierarchicalActionLogContext::default());
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaXray]
        ); // Verify starting state
        runtime.context_mut().log.clear(); // Clear initial entry logs

        let event_processed = runtime.send(TestHierarchyEvent::EventTriggerToSibling);
        assert!(
            event_processed,
            "Event EventTriggerToSibling should have been processed"
        );

        // Expected final state: ChildOneBravo
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::ChildOneBravo]
        );

        // Expected actions:
        // 1. Exit GrandchildOneAlphaXray
        // 2. Exit ChildOneAlpha
        // 3. TransitionAction (defined on ChildOneAlpha -> ChildOneBravo transition)
        // 4. Enter ChildOneBravo
        let mut expected_log: Vec<heapless::String<MAX_LOG_STRING_LEN>, MAX_LOG_ENTRIES> =
            Vec::new();

        let mut s_exit_gcax = heapless::String::<MAX_LOG_STRING_LEN>::new();
        s_exit_gcax.push_str("ExitGrandchildOneAlphaXray").unwrap();
        expected_log.push(s_exit_gcax).unwrap();

        let mut s_exit_c1a = heapless::String::<MAX_LOG_STRING_LEN>::new();
        s_exit_c1a.push_str("ExitChildOneAlpha").unwrap();
        expected_log.push(s_exit_c1a).unwrap();

        let mut s_trans = heapless::String::<MAX_LOG_STRING_LEN>::new();
        s_trans.push_str("TransitionAction").unwrap();
        expected_log.push(s_trans).unwrap();

        let mut s_enter_c1b = heapless::String::<MAX_LOG_STRING_LEN>::new();
        s_enter_c1b.push_str("EnterChildOneBravo").unwrap();
        expected_log.push(s_enter_c1b).unwrap();

        assert_eq!(runtime.context().get_log(), &expected_log);
    }

    #[test]
    fn machine_starts_in_initial_state() {
        const TEST_TRANSITIONS: &[Transition<TestState, TestEvent, TestContextForEmpty>] = &[];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, TestContextForEmpty> =
            MachineDefinition::new(TEST_STATENODES_EMPTY_CTX, TEST_TRANSITIONS, TestState::S0);

        let initial_context = DefaultContext::default();
        let runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);
        assert_eq!(runtime.state().as_slice(), &[TestState::S0]);
    }

    #[test]
    fn send_event_triggers_transition_and_action() {
        const ACTION_TRANSITIONS: &[Transition<TestState, TestEvent, CounterContext>] =
            &[Transition {
                from_state: TestState::S0,
                event: TestEvent::E0,
                to_state: TestState::S1,
                action: Some(increment_action),
                guard: None,
            }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, CounterContext> =
            MachineDefinition::new(
                TEST_STATENODES_COUNTER_CTX,
                ACTION_TRANSITIONS,
                TestState::S0,
            );

        let initial_context = CounterContext { count: 0 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        assert!(runtime.send(TestEvent::E0));
        assert_eq!(runtime.state().as_slice(), &[TestState::S1]);
        assert_eq!(runtime.context().count, 1);
    }

    #[test]
    fn send_event_no_transition_if_guard_fails() {
        const GUARDED_TRANSITIONS: &[Transition<TestState, TestEvent, CounterContext>] =
            &[Transition {
                from_state: TestState::S0,
                event: TestEvent::E0,
                to_state: TestState::S1,
                action: Some(increment_action),
                guard: Some(count_is_zero_guard),
            }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, CounterContext> =
            MachineDefinition::new(
                TEST_STATENODES_COUNTER_CTX,
                GUARDED_TRANSITIONS,
                TestState::S0,
            );

        let mut runtime = Runtime::new(TEST_MACHINE_DEF, CounterContext { count: 1 }); // count is not 0
        assert!(!runtime.send(TestEvent::E0)); // Guard should fail
        assert_eq!(runtime.state().as_slice(), &[TestState::S0]);
        assert_eq!(runtime.context().count, 1); // Action should not run

        let mut runtime_pass = Runtime::new(TEST_MACHINE_DEF, CounterContext { count: 0 }); // count is 0
        assert!(runtime_pass.send(TestEvent::E0)); // Guard should pass
        assert_eq!(runtime_pass.state().as_slice(), &[TestState::S1]);
        assert_eq!(runtime_pass.context().count, 1); // Action should run
    }

    #[test]
    fn context_mut_provides_mutable_access() {
        const NO_TRANSITIONS: &[Transition<TestState, TestEvent, CounterContext>] = &[];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, CounterContext> =
            MachineDefinition::new(TEST_STATENODES_COUNTER_CTX, NO_TRANSITIONS, TestState::S0);

        let initial_context = CounterContext { count: 42 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        runtime.context_mut().count += 1;
        assert_eq!(runtime.context().count, 43);
    }

    #[test]
    fn no_transition_if_event_does_not_match() {
        const TEST_TRANSITIONS: &[Transition<TestState, TestEvent, TestContextForEmpty>] =
            &[Transition {
                from_state: TestState::S0,
                event: TestEvent::E0,
                to_state: TestState::S1,
                action: None,
                guard: None,
            }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, TestContextForEmpty> =
            MachineDefinition::new(TEST_STATENODES_EMPTY_CTX, TEST_TRANSITIONS, TestState::S0);
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, DefaultContext::default());
        assert!(!runtime.send(TestEvent::E1)); // Different event
        assert_eq!(runtime.state().as_slice(), &[TestState::S0]);
    }

    #[test]
    fn no_transition_if_state_does_not_match() {
        const TEST_TRANSITIONS: &[Transition<TestState, TestEvent, TestContextForEmpty>] =
            &[Transition {
                from_state: TestState::S0,
                event: TestEvent::E0,
                to_state: TestState::S1,
                action: None,
                guard: None,
            }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, TestContextForEmpty> =
            MachineDefinition::new(TEST_STATENODES_EMPTY_CTX, TEST_TRANSITIONS, TestState::S1); // Start in S1
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, DefaultContext::default());
        assert!(!runtime.send(TestEvent::E0)); // Event E0 is for S0
        assert_eq!(runtime.state().as_slice(), &[TestState::S1]);
    }

    #[test]
    fn test_child_to_parent_transition() {
        let machine_def = MachineDefinition::new(
            TEST_HIERARCHY_STATENODES,
            TEST_HIERARCHY_TRANSITIONS,
            TestHierarchyState::ParentOne, // Initial: GrandchildOneAlphaXray
        );
        let mut runtime = Runtime::new(machine_def, HierarchicalActionLogContext::default());
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaXray]
        );
        runtime.context_mut().log.clear();

        let event_processed = runtime.send(TestHierarchyEvent::EventTriggerToParent);
        assert!(
            event_processed,
            "Event EventTriggerToParent should have been processed"
        );

        // Expected final state: GrandchildOneAlphaXray (due to re-entry into ChildOneAlpha's initial)
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaXray]
        );

        // Expected actions:
        // 1. Exit GrandchildOneAlphaXray
        // 2. TransitionAction (from GC1AX -> C1A transition)
        // 3. Enter ChildOneAlpha (target of transition)
        // 4. Enter GrandchildOneAlphaXray (initial child of ChildOneAlpha)
        let mut expected_log: Vec<heapless::String<MAX_LOG_STRING_LEN>, MAX_LOG_ENTRIES> =
            Vec::new();
        expected_log
            .push(heapless::String::try_from("ExitGrandchildOneAlphaXray").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("TransitionAction").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterChildOneAlpha").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterGrandchildOneAlphaXray").unwrap())
            .unwrap();

        assert_eq!(runtime.context().get_log(), &expected_log);
    }

    #[test]
    fn test_parent_to_child_transition() {
        let machine_def = MachineDefinition::new(
            TEST_HIERARCHY_STATENODES,
            TEST_HIERARCHY_TRANSITIONS,
            TestHierarchyState::ParentOne, // Initial: GrandchildOneAlphaXray
        );
        let mut runtime = Runtime::new(machine_def, HierarchicalActionLogContext::default());
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaXray]
        ); // Current leaf
        runtime.context_mut().log.clear();

        let event_processed = runtime.send(TestHierarchyEvent::EventTriggerP1ToC1B);
        assert!(
            event_processed,
            "Event EventTriggerP1ToC1B should have been processed"
        );

        // Expected final state: ChildOneBravo (since it's a leaf)
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::ChildOneBravo]
        );

        // Expected actions:
        // 1. Exit GrandchildOneAlphaXray
        // 2. Exit ChildOneAlpha
        // (Transition is on ParentOne, exits happen from current leaf up to ParentOne)
        // 3. TransitionAction (from P1 -> C1B transition)
        // 4. Enter ChildOneBravo (target is leaf, directly entered)
        let mut expected_log: Vec<heapless::String<MAX_LOG_STRING_LEN>, MAX_LOG_ENTRIES> =
            Vec::new();
        expected_log
            .push(heapless::String::try_from("ExitGrandchildOneAlphaXray").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("ExitChildOneAlpha").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("TransitionAction").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterChildOneBravo").unwrap())
            .unwrap();

        assert_eq!(runtime.context().get_log(), &expected_log);
    }

    #[test]
    fn test_grandchild_to_grandparent_reentry() {
        // Initial state: ParentOne -> ChildOneAlpha -> GrandchildOneAlphaXray
        // Setup to start in GrandchildOneAlphaYankee for this test.
        // This requires a bit of manual setup or a dedicated initial state for the test.
        // For simplicity, we'll send events to navigate to GrandchildOneAlphaYankee first.

        let machine_def = MachineDefinition::new(
            TEST_HIERARCHY_STATENODES,
            TEST_HIERARCHY_TRANSITIONS,
            TestHierarchyState::ParentOne,
        );
        let mut runtime = Runtime::new(machine_def, HierarchicalActionLogContext::default());
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaXray]
        );

        // Navigate to ChildOneBravo first (sibling of ChildOneAlpha)
        // EventTriggerToSibling is on ChildOneAlpha
        runtime.send(TestHierarchyEvent::EventTriggerToSibling);
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::ChildOneBravo]
        );

        // Navigate from ChildOneBravo to GrandchildOneAlphaYankee
        // EventTriggerToCousinChild is on ChildOneBravo
        runtime.send(TestHierarchyEvent::EventTriggerToCousinChild);
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaYankee]
        ); // Now we are in GCAY

        runtime.context_mut().log.clear(); // Clear log before the actual test transition

        let event_processed = runtime.send(TestHierarchyEvent::EventTriggerToGrandparent);
        assert!(
            event_processed,
            "Event EventTriggerToGrandparent should have been processed"
        );

        // Expected final state: GrandchildOneAlphaXray (ParentOne re-enters its initial path)
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaXray]
        );

        // Expected actions:
        // 1. Exit GrandchildOneAlphaYankee
        // 2. Exit ChildOneAlpha
        // 3. TransitionAction (from GCAY -> P1 transition)
        // 4. Enter ParentOne (target of transition)
        // 5. Enter ChildOneAlpha (initial child of P1)
        // 6. Enter GrandchildOneAlphaXray (initial child of C1A)
        let mut expected_log: Vec<heapless::String<MAX_LOG_STRING_LEN>, MAX_LOG_ENTRIES> =
            Vec::new();
        expected_log
            .push(heapless::String::try_from("ExitGrandchildOneAlphaYankee").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("ExitChildOneAlpha").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("TransitionAction").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterParentOne").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterChildOneAlpha").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterGrandchildOneAlphaXray").unwrap())
            .unwrap();

        assert_eq!(runtime.context().get_log(), &expected_log);
    }

    #[test]
    fn test_cousin_child_transition() {
        // Initial state: ParentOne -> ChildOneAlpha -> GrandchildOneAlphaXray
        // Navigate to ChildOneBravo first.
        let machine_def = MachineDefinition::new(
            TEST_HIERARCHY_STATENODES,
            TEST_HIERARCHY_TRANSITIONS,
            TestHierarchyState::ParentOne,
        );
        let mut runtime = Runtime::new(machine_def, HierarchicalActionLogContext::default());
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaXray]
        );

        // EventTriggerToSibling defined on ChildOneAlpha, from current GCAX, goes up to C1A
        runtime.send(TestHierarchyEvent::EventTriggerToSibling);
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::ChildOneBravo]
        ); // Now in ChildOneBravo
        runtime.context_mut().log.clear();

        let event_processed = runtime.send(TestHierarchyEvent::EventTriggerToCousinChild);
        assert!(
            event_processed,
            "Event EventTriggerToCousinChild should have been processed"
        );

        // Expected final state: GrandchildOneAlphaYankee
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaYankee]
        );

        // LCA(ChildOneBravo, GrandchildOneAlphaYankee) is ParentOne.
        // ChildOneBravo is child of ParentOne.
        // GrandchildOneAlphaYankee is child of ChildOneAlpha, which is child of ParentOne.
        // Path from ParentOne (LCA) to GrandchildOneAlphaYankee: ParentOne -> ChildOneAlpha -> GrandchildOneAlphaYankee
        // Expected actions:
        // 1. Exit ChildOneBravo
        // 2. TransitionAction (from C1B -> GCAY transition)
        // 3. Enter ChildOneAlpha (intermediate state on path from LCA's child to target)
        // 4. Enter GrandchildOneAlphaYankee (target state, and it's a leaf)
        let mut expected_log: Vec<heapless::String<MAX_LOG_STRING_LEN>, MAX_LOG_ENTRIES> =
            Vec::new();
        expected_log
            .push(heapless::String::try_from("ExitChildOneBravo").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("TransitionAction").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterChildOneAlpha").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterGrandchildOneAlphaYankee").unwrap())
            .unwrap();

        assert_eq!(runtime.context().get_log(), &expected_log);
    }

    #[test]
    fn test_cross_top_level_parent_transition() {
        // Initial state: ParentOne -> ChildOneAlpha -> GrandchildOneAlphaXray
        let machine_def = MachineDefinition::new(
            TEST_HIERARCHY_STATENODES,
            TEST_HIERARCHY_TRANSITIONS,
            TestHierarchyState::ParentOne,
        );
        let mut runtime = Runtime::new(machine_def, HierarchicalActionLogContext::default());
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::GrandchildOneAlphaXray]
        );
        runtime.context_mut().log.clear();

        // EventTriggerP1ToP2 is defined on ParentOne.
        // Current state GCAX will bubble up to P1 to find this transition.
        let event_processed = runtime.send(TestHierarchyEvent::EventTriggerP1ToP2);
        assert!(
            event_processed,
            "Event EventTriggerP1ToP2 should have been processed"
        );

        // Expected final state: ChildTwoAlpha (ParentTwo re-enters its initial path)
        assert_eq!(
            runtime.state().as_slice(),
            &[TestHierarchyState::ChildTwoAlpha]
        );

        // LCA(GrandchildOneAlphaXray, ParentTwo) is None (or conceptual root).
        // Exit path from GCAX: GCAX -> C1A -> P1
        // Entry path to CTA (initial of P2): P2 -> CTA
        // Expected actions:
        // 1. Exit GrandchildOneAlphaXray
        // 2. Exit ChildOneAlpha
        // 3. Exit ParentOne
        // 4. TransitionAction (from P1 -> P2 transition)
        // 5. Enter ParentTwo
        // 6. Enter ChildTwoAlpha (initial child of P2)
        let mut expected_log: Vec<heapless::String<MAX_LOG_STRING_LEN>, MAX_LOG_ENTRIES> =
            Vec::new();
        expected_log
            .push(heapless::String::try_from("ExitGrandchildOneAlphaXray").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("ExitChildOneAlpha").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("ExitParentOne").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("TransitionAction").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterParentTwo").unwrap())
            .unwrap();
        expected_log
            .push(heapless::String::try_from("EnterChildTwoAlpha").unwrap())
            .unwrap();

        assert_eq!(runtime.context().get_log(), &expected_log);
    }

    // --- Tests for Multiple Guard Selection ---

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum MultiGuardTestState {
        InitialState,
        TargetStateOne,
        TargetStateTwo,
        TargetStateThree,
    }

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum MultiGuardTestEvent {
        TriggerEvent,
    }

    #[derive(Clone, Debug, Default, PartialEq, Eq)]
    struct MultiGuardContext {
        selector_value: i32,
        action_taken_for: Option<MultiGuardTestState>,
    }

    fn guard_for_target_one(context: &MultiGuardContext, _event: MultiGuardTestEvent) -> bool {
        context.selector_value == 1
    }
    fn action_for_target_one(context: &mut MultiGuardContext) {
        context.action_taken_for = Some(MultiGuardTestState::TargetStateOne);
    }

    fn guard_for_target_two(context: &MultiGuardContext, _event: MultiGuardTestEvent) -> bool {
        context.selector_value == 2
    }
    fn action_for_target_two(context: &mut MultiGuardContext) {
        context.action_taken_for = Some(MultiGuardTestState::TargetStateTwo);
    }

    fn guard_for_target_three(context: &MultiGuardContext, _event: MultiGuardTestEvent) -> bool {
        context.selector_value == 3
    }
    fn action_for_target_three(context: &mut MultiGuardContext) {
        context.action_taken_for = Some(MultiGuardTestState::TargetStateThree);
    }

    const MULTI_GUARD_STATENODES: &[StateNode<MultiGuardTestState, MultiGuardContext>] = &[
        StateNode {
            id: MultiGuardTestState::InitialState,
            parent: None,
            initial_child: None,
            entry_action: None,
            exit_action: None,
            is_parallel: false,
        },
        StateNode {
            id: MultiGuardTestState::TargetStateOne,
            parent: None,
            initial_child: None,
            entry_action: None,
            exit_action: None,
            is_parallel: false,
        },
        StateNode {
            id: MultiGuardTestState::TargetStateTwo,
            parent: None,
            initial_child: None,
            entry_action: None,
            exit_action: None,
            is_parallel: false,
        },
        StateNode {
            id: MultiGuardTestState::TargetStateThree,
            parent: None,
            initial_child: None,
            entry_action: None,
            exit_action: None,
            is_parallel: false,
        },
    ];

    const MULTI_GUARD_TRANSITIONS: &[Transition<
        MultiGuardTestState,
        MultiGuardTestEvent,
        MultiGuardContext,
    >] = &[
        Transition {
            from_state: MultiGuardTestState::InitialState,
            event: MultiGuardTestEvent::TriggerEvent,
            to_state: MultiGuardTestState::TargetStateOne,
            action: Some(action_for_target_one),
            guard: Some(guard_for_target_one),
        },
        Transition {
            from_state: MultiGuardTestState::InitialState,
            event: MultiGuardTestEvent::TriggerEvent,
            to_state: MultiGuardTestState::TargetStateTwo,
            action: Some(action_for_target_two),
            guard: Some(guard_for_target_two),
        },
        Transition {
            from_state: MultiGuardTestState::InitialState,
            event: MultiGuardTestEvent::TriggerEvent,
            to_state: MultiGuardTestState::TargetStateThree,
            action: Some(action_for_target_three),
            guard: Some(guard_for_target_three),
        },
    ];

    #[test]
    fn test_multiple_guards_selects_correct_transition() {
        let machine_def = MachineDefinition::new(
            MULTI_GUARD_STATENODES,
            MULTI_GUARD_TRANSITIONS,
            MultiGuardTestState::InitialState,
        );

        // Scenario 1: Guard for TargetStateOne passes
        let mut runtime1 = Runtime::new(
            machine_def.clone(),
            MultiGuardContext {
                selector_value: 1,
                action_taken_for: None,
            },
        );
        assert!(runtime1.send(MultiGuardTestEvent::TriggerEvent));
        assert_eq!(
            runtime1.state().as_slice(),
            &[MultiGuardTestState::TargetStateOne]
        );
        assert_eq!(
            runtime1.context().action_taken_for,
            Some(MultiGuardTestState::TargetStateOne)
        );

        // Scenario 2: Guard for TargetStateTwo passes
        let mut runtime2 = Runtime::new(
            machine_def.clone(),
            MultiGuardContext {
                selector_value: 2,
                action_taken_for: None,
            },
        );
        assert!(runtime2.send(MultiGuardTestEvent::TriggerEvent));
        assert_eq!(
            runtime2.state().as_slice(),
            &[MultiGuardTestState::TargetStateTwo]
        );
        assert_eq!(
            runtime2.context().action_taken_for,
            Some(MultiGuardTestState::TargetStateTwo)
        );

        // Scenario 3: Guard for TargetStateThree passes
        let mut runtime3 = Runtime::new(
            machine_def.clone(),
            MultiGuardContext {
                selector_value: 3,
                action_taken_for: None,
            },
        );
        assert!(runtime3.send(MultiGuardTestEvent::TriggerEvent));
        assert_eq!(
            runtime3.state().as_slice(),
            &[MultiGuardTestState::TargetStateThree]
        );
        assert_eq!(
            runtime3.context().action_taken_for,
            Some(MultiGuardTestState::TargetStateThree)
        );

        // Scenario 4: No guard passes
        let mut runtime4 = Runtime::new(
            machine_def.clone(),
            MultiGuardContext {
                selector_value: 4,
                action_taken_for: None,
            },
        );
        assert!(!runtime4.send(MultiGuardTestEvent::TriggerEvent));
        assert_eq!(
            runtime4.state().as_slice(),
            &[MultiGuardTestState::InitialState]
        );
        assert_eq!(runtime4.context().action_taken_for, None);

        // Scenario 5: First matching guard (selector_value = 1) even if others would also pass
        // This relies on the order of transitions in MULTI_GUARD_TRANSITIONS
        // and the runtime iterating them in that order.
        let mut runtime5 = Runtime::new(
            machine_def.clone(),
            MultiGuardContext {
                selector_value: 1,
                action_taken_for: None,
            },
        );
        // (If guards could somehow make selector_value change to 2 mid-evaluation, this test would be more complex,
        // but simple guards don't do that. Assuming guards are pure functions of context and event.)
        assert!(runtime5.send(MultiGuardTestEvent::TriggerEvent));
        assert_eq!(
            runtime5.state().as_slice(),
            &[MultiGuardTestState::TargetStateOne],
            "Expected TargetStateOne due to transition order"
        );
        assert_eq!(
            runtime5.context().action_taken_for,
            Some(MultiGuardTestState::TargetStateOne)
        );
    }
}
