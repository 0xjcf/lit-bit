// src/core/mod.rs
// This module will house core state machine logic and types.
// For now, it's a placeholder.

// Re-export the StateMachine trait for easier use if core types implement it.
// Potentially, the macro-generated machine would be in a submodule of `core` or a user module.
pub use crate::StateMachine;

// --- Basic Type Placeholders (will be generic/generated by macro later) ---

// Using simple u8 for IDs as placeholders. Macro would generate enums.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct StateId(pub u8);

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct EventId(pub u8);

// Placeholder for context data. Macro would use the user-defined struct.
#[derive(Debug, Clone, Default)]
pub struct DefaultContext {/* ... fields ... */}

// Define function pointer types for actions and guards
pub type ActionFn<ContextType> = fn(&mut ContextType);
pub type GuardFn<ContextType, EventType> = fn(context: &ContextType, event: EventType) -> bool;

// --- Flat State Machine Definition ---

/// Represents a simple transition for a flat state machine.
#[derive(Debug, Copy, Clone)]
pub struct Transition<StateType, EventType, ContextType> {
    pub from_state: StateType,
    pub event: EventType,
    pub to_state: StateType,
    pub action: Option<ActionFn<ContextType>>,
    pub guard: Option<GuardFn<ContextType, EventType>>,
}

/// Defines the structure of a simple, flat state machine.
/// This would be largely generated by the `statechart!` macro.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct StateNode<S, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    C: Clone + 'static,
{
    pub id: S, // The unique ID of this state (a variant of the generated StateId enum)
    pub parent: Option<S>, // ID of the parent state, if any
    pub initial_child: Option<S>, // ID of the initial child state, if this is a composite state
    pub entry_action: Option<ActionFn<C>>,
    pub exit_action: Option<ActionFn<C>>,
}

#[derive(Clone)]
pub struct MachineDefinition<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static, // This will be the generated StateId enum
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    C: Clone + 'static,
{
    pub states: &'static [StateNode<S, C>],
    pub transitions: &'static [Transition<S, E, C>],
    pub initial_leaf_state: S,
}

// Manual Debug impl to avoid requiring S, E, C to be Debug for MachineDefinition itself to be Debug
impl<S, E, C> core::fmt::Debug for MachineDefinition<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    C: Clone + core::fmt::Debug + 'static,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("MachineDefinition")
            .field("states", &self.states) // StateNode needs Debug for this to be useful
            .field("transitions", &self.transitions)
            .field("initial_leaf_state", &self.initial_leaf_state)
            .finish()
    }
}

impl<S, E, C> MachineDefinition<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    C: Clone + 'static,
{
    pub const fn new(
        states: &'static [StateNode<S, C>],
        transitions: &'static [Transition<S, E, C>],
        initial_leaf_state: S,
    ) -> Self {
        MachineDefinition {
            states,
            transitions,
            initial_leaf_state,
        }
    }
}

// --- Runtime Instance ---

/// Runtime instance of a state machine.
#[derive(Debug)]
pub struct Runtime<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    C: Clone + 'static,
{
    machine_def: MachineDefinition<S, E, C>,
    current_state_id: S,
    context: C,
}

impl<S, E, C> Runtime<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static, // Added Debug here for logging etc.
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static, // Added Debug here
    C: Clone + 'static,
{
    /// Creates a new runtime instance for the given machine definition and initial context.
    pub fn new(machine_def: MachineDefinition<S, E, C>, initial_context: C) -> Self {
        // When a machine is created, we might want to fire entry actions
        // for the initial state and its parents.
        // This logic will be added in a later step (Task E.3 from design huddle).
        // For now, just set the current state.
        let initial_state = machine_def.initial_leaf_state; // Read initial_leaf_state before machine_def is moved
        Runtime {
            machine_def,                     // machine_def is moved here
            current_state_id: initial_state, // Use the value read before the move
            context: initial_context,
        }
    }

    pub fn state(&self) -> S {
        self.current_state_id
    }

    pub fn context(&self) -> &C {
        &self.context
    }

    pub fn context_mut(&mut self) -> &mut C {
        &mut self.context
    }

    pub fn send(&mut self, event: E) -> bool {
        for transition in self.machine_def.transitions {
            if transition.from_state == self.current_state_id && transition.event == event {
                // Guard check
                if let Some(guard_fn) = transition.guard {
                    if !guard_fn(&self.context, event) {
                        continue;
                    }
                }

                // --- TODO: Phase 2 - Hierarchy & Guards ---
                // 1. Call exit actions: from current_state_id up to the common ancestor
                //    of current_state_id and transition.to_state.
                //    (This requires finding the common ancestor and path traversal using self.machine_def.states)

                self.current_state_id = transition.to_state;

                // 2. Call transition action (if any)
                if let Some(action) = transition.action {
                    action(&mut self.context);
                }

                // 3. Call entry actions: from the common ancestor (or just above it)
                //    down to the new self.current_state_id (transition.to_state).
                //    (This requires path traversal using self.machine_def.states)

                // --- End TODO ---
                return true;
            }
        }
        false
    }
}

impl<S, E, C> StateMachine for Runtime<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    C: Clone + 'static,
{
    type State = S;
    type Event = E;
    type Context = C;

    fn send(&mut self, event: Self::Event) -> bool {
        self.send(event)
    }

    fn state(&self) -> Self::State {
        self.current_state_id
    }

    fn context(&self) -> &Self::Context {
        &self.context
    }

    fn context_mut(&mut self) -> &mut Self::Context {
        &mut self.context
    }
}

#[cfg(test)]
mod tests {
    use super::*; //Imports S, E, C types from parent
    use crate::core::DefaultContext; // Ensure DefaultContext is in scope

    #[allow(dead_code)] // Allow dead code for S2 variant and potentially others during dev
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestState {
        S0,
        S1,
        S2,
    }

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestEvent {
        E0,
        E1,
    }

    type TestContext = DefaultContext; // Or any specific context for tests

    // Define CounterContext at the module scope for tests
    #[derive(Clone, Debug, Default, PartialEq, Eq)]
    struct CounterContext {
        count: i32,
    }

    fn increment_action(context: &mut CounterContext) {
        context.count += 1;
    }
    fn count_is_zero_guard(context: &CounterContext, _event: TestEvent) -> bool {
        context.count == 0
    }

    // Placeholder for states, to be generated by macro later
    const TEST_STATENODES: &[StateNode<TestState, TestContext>] = &[];
    const TEST_STATENODES_COUNTER_CTX: &[StateNode<TestState, CounterContext>] = &[];

    #[test]
    fn machine_starts_in_initial_state() {
        const TEST_TRANSITIONS: &[Transition<TestState, TestEvent, TestContext>] = &[];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, TestContext> =
            MachineDefinition::new(TEST_STATENODES, TEST_TRANSITIONS, TestState::S0);

        let initial_context = DefaultContext::default();
        let runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);
        assert_eq!(runtime.state(), TestState::S0);
    }

    #[test]
    fn send_event_triggers_transition_and_action() {
        const ACTION_TRANSITIONS: &[Transition<TestState, TestEvent, CounterContext>] =
            &[Transition {
                from_state: TestState::S0,
                event: TestEvent::E0,
                to_state: TestState::S1,
                action: Some(increment_action),
                guard: None,
            }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, CounterContext> =
            MachineDefinition::new(
                TEST_STATENODES_COUNTER_CTX,
                ACTION_TRANSITIONS,
                TestState::S0,
            );

        let initial_context = CounterContext { count: 0 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        assert!(runtime.send(TestEvent::E0));
        assert_eq!(runtime.state(), TestState::S1);
        assert_eq!(runtime.context().count, 1);
    }

    #[test]
    fn send_event_no_transition_if_guard_fails() {
        const GUARDED_TRANSITIONS: &[Transition<TestState, TestEvent, CounterContext>] =
            &[Transition {
                from_state: TestState::S0,
                event: TestEvent::E0,
                to_state: TestState::S1,
                action: Some(increment_action),
                guard: Some(count_is_zero_guard),
            }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, CounterContext> =
            MachineDefinition::new(
                TEST_STATENODES_COUNTER_CTX,
                GUARDED_TRANSITIONS,
                TestState::S0,
            );

        let mut runtime = Runtime::new(TEST_MACHINE_DEF, CounterContext { count: 1 }); // count is not 0
        assert!(!runtime.send(TestEvent::E0)); // Guard should fail
        assert_eq!(runtime.state(), TestState::S0);
        assert_eq!(runtime.context().count, 1); // Action should not run

        let mut runtime_pass = Runtime::new(TEST_MACHINE_DEF, CounterContext { count: 0 }); // count is 0
        assert!(runtime_pass.send(TestEvent::E0)); // Guard should pass
        assert_eq!(runtime_pass.state(), TestState::S1);
        assert_eq!(runtime_pass.context().count, 1); // Action should run
    }

    #[test]
    fn context_mut_provides_mutable_access() {
        const NO_TRANSITIONS: &[Transition<TestState, TestEvent, CounterContext>] = &[];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, CounterContext> =
            MachineDefinition::new(TEST_STATENODES_COUNTER_CTX, NO_TRANSITIONS, TestState::S0);

        let initial_context = CounterContext { count: 42 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        runtime.context_mut().count += 1;
        assert_eq!(runtime.context().count, 43);
    }

    #[test]
    fn no_transition_if_event_does_not_match() {
        const TEST_TRANSITIONS: &[Transition<TestState, TestEvent, TestContext>] = &[Transition {
            from_state: TestState::S0,
            event: TestEvent::E0,
            to_state: TestState::S1,
            action: None,
            guard: None,
        }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, TestContext> =
            MachineDefinition::new(TEST_STATENODES, TEST_TRANSITIONS, TestState::S0);
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, DefaultContext::default());
        assert!(!runtime.send(TestEvent::E1)); // Different event
        assert_eq!(runtime.state(), TestState::S0);
    }

    #[test]
    fn no_transition_if_state_does_not_match() {
        const TEST_TRANSITIONS: &[Transition<TestState, TestEvent, TestContext>] = &[Transition {
            from_state: TestState::S0,
            event: TestEvent::E0,
            to_state: TestState::S1,
            action: None,
            guard: None,
        }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, TestContext> =
            MachineDefinition::new(TEST_STATENODES, TEST_TRANSITIONS, TestState::S1); // Start in S1
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, DefaultContext::default());
        assert!(!runtime.send(TestEvent::E0)); // Event E0 is for S0
        assert_eq!(runtime.state(), TestState::S1);
    }
}
