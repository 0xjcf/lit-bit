// src/core/mod.rs
// This module will house core state machine logic and types.
// For now, it's a placeholder.

// Re-export the StateMachine trait for easier use if core types implement it.
// Potentially, the macro-generated machine would be in a submodule of `core` or a user module.
pub use crate::StateMachine;

// --- Basic Type Placeholders (will be generic/generated by macro later) ---

// Using simple u8 for IDs as placeholders. Macro would generate enums.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct StateId(pub u8);

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct EventId(pub u8);

// Placeholder for context data. Macro would use the user-defined struct.
#[derive(Debug, Clone, Default)]
pub struct DefaultContext {/* ... fields ... */}

// Define function pointer types for actions and guards
pub type ActionFn<ContextType> = fn(&mut ContextType);
pub type GuardFn<ContextType, EventType> = fn(context: &ContextType, event: EventType) -> bool;

// --- Flat State Machine Definition ---

/// Represents a simple transition for a flat state machine.
#[derive(Debug, Copy, Clone)]
pub struct Transition<StateType, EventType, ContextType> {
    pub from_state: StateType,
    pub event: EventType,
    pub to_state: StateType,
    pub action: Option<ActionFn<ContextType>>,
    pub guard: Option<GuardFn<ContextType, EventType>>,
}

/// Defines the structure of a simple, flat state machine.
/// This would be largely generated by the `statechart!` macro.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct StateNode<S, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    C: Clone + 'static,
{
    pub id: S, // The unique ID of this state (a variant of the generated StateId enum)
    pub parent: Option<S>, // ID of the parent state, if any
    pub initial_child: Option<S>, // ID of the initial child state, if this is a composite state
    pub entry_action: Option<ActionFn<C>>,
    pub exit_action: Option<ActionFn<C>>,
}

#[derive(Clone)]
pub struct MachineDefinition<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static, // This will be the generated StateId enum
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    C: Clone + 'static,
{
    pub states: &'static [StateNode<S, C>],
    pub transitions: &'static [Transition<S, E, C>],
    pub initial_leaf_state: S,
}

// Manual Debug impl to avoid requiring S, E, C to be Debug for MachineDefinition itself to be Debug
impl<S, E, C> core::fmt::Debug for MachineDefinition<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    C: Clone + core::fmt::Debug + 'static,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("MachineDefinition")
            .field("states", &self.states) // StateNode needs Debug for this to be useful
            .field("transitions", &self.transitions)
            .field("initial_leaf_state", &self.initial_leaf_state)
            .finish()
    }
}

impl<S, E, C> MachineDefinition<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    C: Clone + 'static,
{
    pub const fn new(
        states: &'static [StateNode<S, C>],
        transitions: &'static [Transition<S, E, C>],
        initial_leaf_state: S,
    ) -> Self {
        MachineDefinition {
            states,
            transitions,
            initial_leaf_state,
        }
    }
}

// --- Runtime Instance ---

/// Runtime instance of a state machine.
#[derive(Debug)]
pub struct Runtime<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + 'static,
    C: Clone + 'static,
{
    machine_def: MachineDefinition<S, E, C>,
    current_state_id: S,
    context: C,
}

impl<S, E, C> Runtime<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static, // Added Debug here for logging etc.
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static, // Added Debug here
    C: Clone + 'static,
{
    /// Creates a new runtime instance for the given machine definition and initial context.
    pub fn new(machine_def: MachineDefinition<S, E, C>, mut initial_context: C) -> Self {
        let initial_state_id = machine_def.initial_leaf_state;

        // Execute entry action for the initial state
        if let Some(initial_state_node) =
            machine_def.states.iter().find(|s| s.id == initial_state_id)
        {
            if let Some(entry_fn) = initial_state_node.entry_action {
                entry_fn(&mut initial_context); // Call entry action
            }
        }
        // TODO: Phase 2 - Hierarchy: Execute entry actions for parents of the initial state.

        Runtime {
            machine_def,
            current_state_id: initial_state_id,
            context: initial_context,
        }
    }

    pub fn state(&self) -> S {
        self.current_state_id
    }

    pub fn context(&self) -> &C {
        &self.context
    }

    pub fn context_mut(&mut self) -> &mut C {
        &mut self.context
    }

    pub fn send(&mut self, event: E) -> bool {
        for transition in self.machine_def.transitions {
            if transition.from_state == self.current_state_id && transition.event == event {
                // Guard check
                if let Some(guard_fn) = transition.guard {
                    if !guard_fn(&self.context, event) {
                        continue; // Guard failed, try next transition
                    }
                }

                let old_state_id = self.current_state_id;
                let new_state_id = transition.to_state;

                // 1. Call exit action for the current (old) state if it's different from the new state
                if old_state_id != new_state_id {
                    if let Some(old_state_node) = self
                        .machine_def
                        .states
                        .iter()
                        .find(|s| s.id == old_state_id)
                    {
                        if let Some(exit_fn) = old_state_node.exit_action {
                            exit_fn(&mut self.context);
                        }
                    }
                }
                // TODO: Phase 2 - Hierarchy: Handle exit actions for parent states up to LCA.

                // Update current state
                self.current_state_id = new_state_id;

                // 2. Call transition action (if any) - this should always run, even for self-transitions
                if let Some(action_fn) = transition.action {
                    action_fn(&mut self.context);
                }

                // 3. Call entry action for the new state if it's different from the old state
                if old_state_id != new_state_id {
                    if let Some(new_state_node) = self
                        .machine_def
                        .states
                        .iter()
                        .find(|s| s.id == new_state_id)
                    {
                        if let Some(entry_fn) = new_state_node.entry_action {
                            entry_fn(&mut self.context);
                        }
                    }
                }
                // TODO: Phase 2 - Hierarchy: Handle entry actions for parent states down from LCA.

                return true; // Transition occurred
            }
        }
        false // No matching transition found
    }
}

impl<S, E, C> StateMachine for Runtime<S, E, C>
where
    S: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    E: Copy + Clone + PartialEq + Eq + core::hash::Hash + core::fmt::Debug + 'static,
    C: Clone + 'static,
{
    type State = S;
    type Event = E;
    type Context = C;

    fn send(&mut self, event: Self::Event) -> bool {
        self.send(event)
    }

    fn state(&self) -> Self::State {
        self.current_state_id
    }

    fn context(&self) -> &Self::Context {
        &self.context
    }

    fn context_mut(&mut self) -> &mut Self::Context {
        &mut self.context
    }
}

#[cfg(test)]
mod tests {
    use super::*; //Imports S, E, C types from parent
    use crate::core::DefaultContext; // Ensure DefaultContext is in scope

    #[allow(dead_code)] // Allow dead code for S2 variant and potentially others during dev
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestState {
        S0,
        S1,
        S2,
    }

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestEvent {
        E0,
        E1,
    }

    type TestContext = DefaultContext; // Or any specific context for tests

    // Define CounterContext at the module scope for tests
    #[derive(Clone, Debug, Default, PartialEq, Eq)]
    struct CounterContext {
        count: i32,
    }

    fn increment_action(context: &mut CounterContext) {
        context.count += 1;
    }
    fn count_is_zero_guard(context: &CounterContext, _event: TestEvent) -> bool {
        context.count == 0
    }

    // Placeholder for states, to be generated by macro later
    const TEST_STATENODES: &[StateNode<TestState, TestContext>] = &[];
    const TEST_STATENODES_COUNTER_CTX: &[StateNode<TestState, CounterContext>] = &[];

    #[test]
    fn machine_starts_in_initial_state() {
        const TEST_TRANSITIONS: &[Transition<TestState, TestEvent, TestContext>] = &[];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, TestContext> =
            MachineDefinition::new(TEST_STATENODES, TEST_TRANSITIONS, TestState::S0);

        let initial_context = DefaultContext::default();
        let runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);
        assert_eq!(runtime.state(), TestState::S0);
    }

    #[test]
    fn send_event_triggers_transition_and_action() {
        const ACTION_TRANSITIONS: &[Transition<TestState, TestEvent, CounterContext>] =
            &[Transition {
                from_state: TestState::S0,
                event: TestEvent::E0,
                to_state: TestState::S1,
                action: Some(increment_action),
                guard: None,
            }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, CounterContext> =
            MachineDefinition::new(
                TEST_STATENODES_COUNTER_CTX,
                ACTION_TRANSITIONS,
                TestState::S0,
            );

        let initial_context = CounterContext { count: 0 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        assert!(runtime.send(TestEvent::E0));
        assert_eq!(runtime.state(), TestState::S1);
        assert_eq!(runtime.context().count, 1);
    }

    #[test]
    fn send_event_no_transition_if_guard_fails() {
        const GUARDED_TRANSITIONS: &[Transition<TestState, TestEvent, CounterContext>] =
            &[Transition {
                from_state: TestState::S0,
                event: TestEvent::E0,
                to_state: TestState::S1,
                action: Some(increment_action),
                guard: Some(count_is_zero_guard),
            }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, CounterContext> =
            MachineDefinition::new(
                TEST_STATENODES_COUNTER_CTX,
                GUARDED_TRANSITIONS,
                TestState::S0,
            );

        let mut runtime = Runtime::new(TEST_MACHINE_DEF, CounterContext { count: 1 }); // count is not 0
        assert!(!runtime.send(TestEvent::E0)); // Guard should fail
        assert_eq!(runtime.state(), TestState::S0);
        assert_eq!(runtime.context().count, 1); // Action should not run

        let mut runtime_pass = Runtime::new(TEST_MACHINE_DEF, CounterContext { count: 0 }); // count is 0
        assert!(runtime_pass.send(TestEvent::E0)); // Guard should pass
        assert_eq!(runtime_pass.state(), TestState::S1);
        assert_eq!(runtime_pass.context().count, 1); // Action should run
    }

    #[test]
    fn context_mut_provides_mutable_access() {
        const NO_TRANSITIONS: &[Transition<TestState, TestEvent, CounterContext>] = &[];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, CounterContext> =
            MachineDefinition::new(TEST_STATENODES_COUNTER_CTX, NO_TRANSITIONS, TestState::S0);

        let initial_context = CounterContext { count: 42 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        runtime.context_mut().count += 1;
        assert_eq!(runtime.context().count, 43);
    }

    #[test]
    fn no_transition_if_event_does_not_match() {
        const TEST_TRANSITIONS: &[Transition<TestState, TestEvent, TestContext>] = &[Transition {
            from_state: TestState::S0,
            event: TestEvent::E0,
            to_state: TestState::S1,
            action: None,
            guard: None,
        }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, TestContext> =
            MachineDefinition::new(TEST_STATENODES, TEST_TRANSITIONS, TestState::S0);
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, DefaultContext::default());
        assert!(!runtime.send(TestEvent::E1)); // Different event
        assert_eq!(runtime.state(), TestState::S0);
    }

    #[test]
    fn no_transition_if_state_does_not_match() {
        const TEST_TRANSITIONS: &[Transition<TestState, TestEvent, TestContext>] = &[Transition {
            from_state: TestState::S0,
            event: TestEvent::E0,
            to_state: TestState::S1,
            action: None,
            guard: None,
        }];
        const TEST_MACHINE_DEF: MachineDefinition<TestState, TestEvent, TestContext> =
            MachineDefinition::new(TEST_STATENODES, TEST_TRANSITIONS, TestState::S1); // Start in S1
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, DefaultContext::default());
        assert!(!runtime.send(TestEvent::E0)); // Event E0 is for S0
        assert_eq!(runtime.state(), TestState::S1);
    }
}
