// src/core/mod.rs
// This module will house core state machine logic and types.
// For now, it's a placeholder.

// Re-export the StateMachine trait for easier use if core types implement it.
// Potentially, the macro-generated machine would be in a submodule of `core` or a user module.
pub use crate::StateMachine;

// --- Basic Type Placeholders (will be generic/generated by macro later) ---

// Using simple u8 for IDs as placeholders. Macro would generate enums.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct StateId(pub u8);

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct EventId(pub u8);

// Placeholder for context data. Macro would use the user-defined struct.
#[derive(Debug, Clone, Default)]
pub struct DefaultContext {/* ... fields ... */}

// Define function pointer types for actions and guards
pub type ActionFn<ContextType> = fn(&mut ContextType);
pub type GuardFn<ContextType> = fn(&ContextType) -> bool;

// --- Flat State Machine Definition ---

/// Represents a simple transition for a flat state machine.
#[derive(Debug, Copy, Clone)]
pub struct Transition<StateType, EventType, ContextType> {
    pub from_state: StateType,
    pub event: EventType,
    pub to_state: StateType,
    pub action: Option<ActionFn<ContextType>>,
    pub guard: Option<GuardFn<ContextType>>,
}

/// Defines the structure of a simple, flat state machine.
/// This would be largely generated by the `statechart!` macro.
#[derive(Debug, Copy, Clone)]
pub struct MachineDefinition<StateType: 'static, EventType: 'static, ContextType: 'static> {
    // In a real machine, states might have entry/exit actions etc.
    // For now, we only need to know the initial state and transitions.
    pub initial_state: StateType,
    pub transitions: &'static [Transition<StateType, EventType, ContextType>],
    _context_phantom: core::marker::PhantomData<ContextType>,
    // Later: pub actions: &'static [fn(&mut ContextType)], pub guards: &'static [fn(&ContextType) -> bool]
}

impl<StateType, EventType, ContextType> MachineDefinition<StateType, EventType, ContextType>
where
    StateType: Copy + Clone + PartialEq + core::fmt::Debug + 'static,
    EventType: Copy + Clone + PartialEq + core::fmt::Debug + 'static,
    ContextType: Clone + 'static,
{
    pub const fn new(
        initial_state: StateType,
        transitions: &'static [Transition<StateType, EventType, ContextType>],
    ) -> Self {
        Self {
            initial_state,
            transitions,
            _context_phantom: core::marker::PhantomData,
        }
    }
}

// --- Runtime Instance ---

/// Runtime instance of a state machine.
#[derive(Debug)]
pub struct Runtime<StateType: 'static, EventType: 'static, ContextType: 'static> {
    definition: MachineDefinition<StateType, EventType, ContextType>,
    current_state: StateType,
    context: ContextType,
}

impl<StateType, EventType, ContextType> Runtime<StateType, EventType, ContextType>
where
    StateType: Copy + Clone + PartialEq + core::fmt::Debug,
    EventType: Copy + Clone + PartialEq + core::fmt::Debug,
    ContextType: Clone,
{
    /// Creates a new runtime instance for the given machine definition and initial context.
    pub fn new(
        definition: MachineDefinition<StateType, EventType, ContextType>,
        initial_context: ContextType,
    ) -> Self {
        Self {
            current_state: definition.initial_state,
            definition,
            context: initial_context,
        }
    }
}

// Implement the StateMachine trait for our basic Runtime
impl<StateType, EventType, ContextType> StateMachine for Runtime<StateType, EventType, ContextType>
where
    StateType: Copy + Clone + PartialEq + core::fmt::Debug + 'static,
    EventType: Copy + Clone + PartialEq + core::fmt::Debug + 'static,
    ContextType: Clone + 'static,
{
    type State = StateType;
    type Event = EventType;
    type Context = ContextType;

    fn send(&mut self, event: Self::Event) -> bool {
        for transition in self.definition.transitions {
            if self.current_state == transition.from_state && event == transition.event {
                // Check guard condition
                if let Some(guard_fn) = transition.guard {
                    if !guard_fn(&self.context) {
                        // Guard is false, transition is blocked
                        // TODO: Potentially log or emit an event indicating a blocked transition
                        continue; // Try the next available transition for this event
                    }
                }

                // TODO: Execute exit action for self.current_state (e.g., from definition.states[self.current_state].exit_action)

                // Execute transition action (if defined)
                if let Some(action_fn) = transition.action {
                    action_fn(&mut self.context);
                }

                // Update current state
                self.current_state = transition.to_state;

                // TODO: Execute entry action for self.current_state (e.g., from definition.states[self.current_state].entry_action)

                return true; // Transition occurred
            }
        }
        false // No transition occurred for the given event from the current state
    }

    fn state(&self) -> Self::State {
        self.current_state
    }

    fn context(&self) -> &Self::Context {
        &self.context
    }

    fn context_mut(&mut self) -> &mut Self::Context {
        &mut self.context
    }
}

#[cfg(test)]
mod tests {
    use super::*; // Import items from the parent module (core)
    use crate::StateMachine; // Import the trait itself if not already in scope via super::*

    // Define simple states, events, and context for testing
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestStateEnum {
        S0,
        S1,
    }

    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    enum TestEventEnum {
        E0,
    }

    // Using DefaultContext from the parent module for simplicity
    type TestContextType = DefaultContext;

    // Test action (does nothing for now)
    // fn test_action(_context: &mut TestContextType) {} // Keep previous test_action for other tests, or make specific

    #[derive(Debug, Clone, PartialEq, Eq, Default)] // Added PartialEq, Eq for potential asserts on context
    struct CounterContext {
        count: u32,
    }

    fn increment_action(context: &mut CounterContext) {
        context.count += 1;
    }

    // Guard functions for testing
    fn is_count_zero(context: &CounterContext) -> bool {
        context.count == 0
    }

    fn is_count_one(context: &CounterContext) -> bool {
        context.count == 1
    }

    #[test]
    fn initial_state() {
        const TEST_TRANSITIONS: &[Transition<TestStateEnum, TestEventEnum, TestContextType>] =
            &[Transition {
                from_state: TestStateEnum::S0,
                event: TestEventEnum::E0,
                to_state: TestStateEnum::S1,
                action: None,
                guard: None,
            }];

        const TEST_MACHINE_DEF: MachineDefinition<TestStateEnum, TestEventEnum, TestContextType> =
            MachineDefinition::new(TestStateEnum::S0, TEST_TRANSITIONS);

        let initial_context = DefaultContext::default();
        let runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        assert_eq!(
            runtime.state(),
            TestStateEnum::S0,
            "Initial state should be S0"
        );
    }

    #[test]
    fn simple_transition() {
        const TEST_TRANSITIONS: &[Transition<TestStateEnum, TestEventEnum, TestContextType>] =
            &[Transition {
                from_state: TestStateEnum::S0,
                event: TestEventEnum::E0,
                to_state: TestStateEnum::S1,
                action: None,
                guard: None,
            }];

        const TEST_MACHINE_DEF: MachineDefinition<TestStateEnum, TestEventEnum, TestContextType> =
            MachineDefinition::new(TestStateEnum::S0, TEST_TRANSITIONS);

        let initial_context = DefaultContext::default();
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        assert_eq!(
            runtime.state(),
            TestStateEnum::S0,
            "Pre-condition: Initial state should be S0"
        );

        let transitioned = runtime.send(TestEventEnum::E0);

        assert!(transitioned, "Event E0 should cause a transition");
        assert_eq!(
            runtime.state(),
            TestStateEnum::S1,
            "Post-condition: State should be S1 after event E0"
        );
    }

    #[test]
    fn ignored_event() {
        // Machine with only one state S0, and no transitions defined.
        const NO_TRANSITIONS: &[Transition<TestStateEnum, TestEventEnum, TestContextType>] = &[];
        const TEST_MACHINE_DEF: MachineDefinition<TestStateEnum, TestEventEnum, TestContextType> =
            MachineDefinition::new(TestStateEnum::S0, NO_TRANSITIONS);

        let initial_context = DefaultContext::default();
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        assert_eq!(
            runtime.state(),
            TestStateEnum::S0,
            "Pre-condition: Initial state should be S0"
        );

        let transitioned = runtime.send(TestEventEnum::E0); // Event E0 is not defined for S0

        assert!(!transitioned, "Event E0 should NOT cause a transition");
        assert_eq!(
            runtime.state(),
            TestStateEnum::S0,
            "Post-condition: State should remain S0"
        );
    }

    #[test]
    fn transition_with_action_modifies_context() {
        const ACTION_TRANSITIONS: &[Transition<TestStateEnum, TestEventEnum, CounterContext>] =
            &[Transition {
                from_state: TestStateEnum::S0,
                event: TestEventEnum::E0,
                to_state: TestStateEnum::S1,
                action: Some(increment_action),
                guard: None,
            }];

        const TEST_MACHINE_DEF: MachineDefinition<TestStateEnum, TestEventEnum, CounterContext> =
            MachineDefinition::new(TestStateEnum::S0, ACTION_TRANSITIONS);

        let initial_context = CounterContext { count: 0 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context.clone()); // Clone if needed for assert later

        assert_eq!(
            runtime.context().count,
            0,
            "Pre-condition: Initial count should be 0"
        );

        let transitioned = runtime.send(TestEventEnum::E0);

        assert!(transitioned, "Event E0 should cause a transition");
        assert_eq!(
            runtime.state(),
            TestStateEnum::S1,
            "Post-condition: State should be S1"
        );
        assert_eq!(
            runtime.context().count,
            1,
            "Post-condition: Count should be incremented by action"
        );
    }

    #[test]
    fn transition_blocked_by_guard() {
        const GUARDED_TRANSITIONS: &[Transition<TestStateEnum, TestEventEnum, CounterContext>] =
            &[Transition {
                from_state: TestStateEnum::S0,
                event: TestEventEnum::E0,
                to_state: TestStateEnum::S1,
                action: None,
                guard: Some(is_count_one), // Guard expects count to be 1, but it will be 0
            }];

        const TEST_MACHINE_DEF: MachineDefinition<TestStateEnum, TestEventEnum, CounterContext> =
            MachineDefinition::new(TestStateEnum::S0, GUARDED_TRANSITIONS);

        let initial_context = CounterContext { count: 0 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        let transitioned = runtime.send(TestEventEnum::E0);

        assert!(!transitioned, "Transition should be blocked by guard");
        assert_eq!(
            runtime.state(),
            TestStateEnum::S0,
            "State should remain S0 if guard blocks"
        );
    }

    #[test]
    fn transition_allowed_by_guard() {
        const GUARDED_TRANSITIONS: &[Transition<TestStateEnum, TestEventEnum, CounterContext>] =
            &[Transition {
                from_state: TestStateEnum::S0,
                event: TestEventEnum::E0,
                to_state: TestStateEnum::S1,
                action: None,
                guard: Some(is_count_zero), // Guard expects count to be 0, which it is
            }];

        const TEST_MACHINE_DEF: MachineDefinition<TestStateEnum, TestEventEnum, CounterContext> =
            MachineDefinition::new(TestStateEnum::S0, GUARDED_TRANSITIONS);

        let initial_context = CounterContext { count: 0 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        let transitioned = runtime.send(TestEventEnum::E0);

        assert!(transitioned, "Transition should be allowed by guard");
        assert_eq!(
            runtime.state(),
            TestStateEnum::S1,
            "State should change to S1 if guard allows"
        );
    }

    #[test]
    fn context_mut_provides_mutable_access() {
        const TEST_MACHINE_DEF: MachineDefinition<TestStateEnum, TestEventEnum, CounterContext> =
            MachineDefinition::new(TestStateEnum::S0, &[]); // No transitions needed for this test

        let initial_context = CounterContext { count: 42 };
        let mut runtime = Runtime::new(TEST_MACHINE_DEF, initial_context);

        // Get mutable context and change it
        let mutable_context = runtime.context_mut();
        mutable_context.count = 100;

        // Verify change through immutable access
        assert_eq!(
            runtime.context().count,
            100,
            "Context should be mutable and reflect changes"
        );
    }
}
